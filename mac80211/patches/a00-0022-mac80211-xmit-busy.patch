--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -4284,6 +4284,15 @@ void ieee80211_stop_queue(struct ieee802
 int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);
 
 /**
+ * ieee80211_queues_stopped - test status of any queue
+ * @hw: pointer as obtained from ieee80211_alloc_hw().
+ *
+ * Return: %true if any queue is stopped. %false otherwise.
+ */
+
+int ieee80211_queues_stopped(struct ieee80211_hw *hw);
+
+/**
  * ieee80211_stop_queues - stop all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2294,6 +2294,13 @@ void __ieee80211_subif_start_xmit(struct
 netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
+#ifdef CPTCFG_MAC80211_NSS_SUPPORT
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+
+	if (ieee80211_queues_stopped(&local->hw))
+		return NETDEV_TX_BUSY;
+#endif
 	__ieee80211_subif_start_xmit(skb, dev, 0);
 	return NETDEV_TX_OK;
 }
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -528,6 +528,27 @@ int ieee80211_queue_stopped(struct ieee8
 }
 EXPORT_SYMBOL(ieee80211_queue_stopped);
 
+int ieee80211_queues_stopped(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+	unsigned long queues = IEEE80211_MAX_QUEUE_MAP;
+	int i, ret;
+
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+
+	for_each_set_bit(i, &queues, hw->queues) {
+		ret = test_bit(IEEE80211_QUEUE_STOP_REASON_DRIVER,
+			       &local->queue_stop_reasons[i]);
+		if (ret)
+			break;
+	}
+
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(ieee80211_queues_stopped);
+
 void ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,
 				     unsigned long queues,
 				     enum queue_stop_reason reason,
