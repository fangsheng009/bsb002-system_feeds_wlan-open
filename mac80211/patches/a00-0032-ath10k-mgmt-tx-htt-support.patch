--- a/drivers/net/wireless/ath/ath10k/htt.h
+++ b/drivers/net/wireless/ath/ath10k/htt.h
@@ -286,24 +286,32 @@ enum htt_t2h_msg_type {
 	HTT_T2H_MSG_TYPE_SEC_IND		= 0xb,
 	HTT_T2H_MSG_TYPE_RC_UPDATE_IND		= 0xc,
 	HTT_T2H_MSG_TYPE_TX_INSPECT_IND		= 0xd,
-	HTT_T2H_MSG_TYPE_MGMT_TX_COMPLETION	= 0xe,
-	HTT_T2H_MSG_TYPE_TX_CREDIT_UPDATE_IND	= 0xf,
-	HTT_T2H_MSG_TYPE_RX_PN_IND		= 0x10,
-	HTT_T2H_MSG_TYPE_RX_OFFLOAD_DELIVER_IND = 0x11,
-	HTT_T2H_MSG_TYPE_RX_IN_ORD_PADDR_IND	= 0x12,
+	HTT_T2H_NUM_BASE_MSGS
+};
+
+enum htt_t2h_msg_type_extn {
+	HTT_T2H_MSG_TYPE_EXTN_MGMT_TX_COMPLETION	= 0xe,
+	HTT_T2H_MSG_TYPE_EXTN_TX_CREDIT_UPDATE_IND	= 0xf,
+	HTT_T2H_MSG_TYPE_EXTN_RX_PN_IND			= 0x10,
+	HTT_T2H_MSG_TYPE_EXTN_RX_OFFLOAD_DELIVER_IND 	= 0x11,
+	HTT_T2H_MSG_TYPE_EXTN_RX_IN_ORD_PADDR_IND	= 0x12,
 	/* 0x13 reservd */
-	HTT_T2H_MSG_TYPE_WDI_IPA_OP_RESPONSE	= 0x14,
+	HTT_T2H_MSG_TYPE_EXTN_WDI_IPA_OP_RESPONSE	= 0x14,
 
 	/* FIXME: Do not depend on this event id. Numbering of this event id is
 	 * broken across different firmware revisions and HTT version fails to
 	 * indicate this.
 	 */
-	HTT_T2H_MSG_TYPE_TEST,
-
-	/* keep this last */
-	HTT_T2H_NUM_MSGS
+	HTT_T2H_MSG_TYPE_EXTN_TEST,
 };
 
+enum htt_t2h_msg_type_extn_10x {
+	HTT_T2H_MSG_TYPE_EXTN_10X_TEST             = 0xe,
+	HTT_T2H_MSG_TYPE_EXTN_10X_CHAN_CHANGE      = 0xf,
+	HTT_T2H_MSG_TYPE_EXTN_10X_AGGR_CONF        = 0x11,
+	HTT_T2H_MSG_TYPE_EXTN_10X_STATS_NOUPLOAD   = 0x12,
+	HTT_T2H_MSG_TYPE_EXTN_10X_MGMT_TX_COMPL_IND= 0x13,
+};
 /*
  * htt_resp_hdr - header for target-to-host messages
  *
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -1892,6 +1892,72 @@ static void ath10k_htt_rx_in_ord_ind(str
 	tasklet_schedule(&htt->rx_replenish_task);
 }
 
+static void ath10k_htt_t2h_mgmt_tx_complete(struct ath10k_htt *htt,
+					    struct htt_mgmt_tx_completion *resp)
+{
+	struct htt_tx_done tx_done = {};
+	int status = __le32_to_cpu(resp->status);
+
+	tx_done.msdu_id =
+		__le32_to_cpu(resp->desc_id);
+
+	switch (status) {
+	case HTT_MGMT_TX_STATUS_OK:
+		tx_done.success = true;
+		break;
+	case HTT_MGMT_TX_STATUS_RETRY:
+		tx_done.no_ack = true;
+		break;
+	case HTT_MGMT_TX_STATUS_DROP:
+		tx_done.discard = true;
+		break;
+	}
+
+	spin_lock_bh(&htt->tx_lock);
+	ath10k_txrx_tx_unref(htt, &tx_done);
+	spin_unlock_bh(&htt->tx_lock);
+}
+
+static void ath10k_htt_t2h_msg_extn_handler(struct ath10k *ar,
+					    struct sk_buff *skb)
+{
+	struct ath10k_htt *htt = &ar->htt;
+	struct htt_resp *resp = (struct htt_resp *)skb->data;
+
+	switch (resp->hdr.msg_type) {
+	case HTT_T2H_MSG_TYPE_EXTN_MGMT_TX_COMPLETION: {
+		ath10k_htt_t2h_mgmt_tx_complete(htt, &resp->mgmt_tx_completion);
+		break;
+	}
+	case HTT_T2H_MSG_TYPE_EXTN_TX_CREDIT_UPDATE_IND:
+		break;
+	case HTT_T2H_MSG_TYPE_EXTN_RX_IN_ORD_PADDR_IND: {
+		spin_lock_bh(&htt->rx_ring.lock);
+		__skb_queue_tail(&htt->rx_in_ord_compl_q, skb);
+		spin_unlock_bh(&htt->rx_ring.lock);
+		tasklet_schedule(&htt->txrx_compl_task);
+		return;
+	}
+	default:
+		break;
+	}
+}
+
+static void ath10k_htt_t2h_msg_extn_10x_handler(struct ath10k *ar,
+						struct sk_buff *skb)
+{
+	struct ath10k_htt *htt = &ar->htt;
+	struct htt_resp *resp = (struct htt_resp *)skb->data;
+
+	switch (resp->hdr.msg_type) {
+	case HTT_T2H_MSG_TYPE_EXTN_10X_MGMT_TX_COMPL_IND:
+		ath10k_htt_t2h_mgmt_tx_complete(htt, &resp->mgmt_tx_completion);
+		break;
+	default:
+		break;
+	}
+}
+
 void ath10k_htt_t2h_msg_handler(struct ath10k *ar, struct sk_buff *skb)
 {
 	struct ath10k_htt *htt = &ar->htt;
@@ -1903,6 +1969,16 @@ void ath10k_htt_t2h_msg_handler(struct a
 
 	ath10k_dbg(ar, ATH10K_DBG_HTT, "htt rx, msg_type: 0x%0X\n",
 		   resp->hdr.msg_type);
+
+	if (resp->hdr.msg_type >= HTT_T2H_NUM_BASE_MSGS) {
+		if (test_bit(ATH10K_FW_FEATURE_WMI_10X, ar->fw_features) ||
+		    (ar->wmi.op_version == ATH10K_FW_WMI_OP_VERSION_10_2_4))
+			ath10k_htt_t2h_msg_extn_10x_handler(ar, skb);
+		else
+			ath10k_htt_t2h_msg_extn_handler(ar, skb);
+		goto out;
+	}
+
 	switch (resp->hdr.msg_type) {
 	case HTT_T2H_MSG_TYPE_VERSION_CONF: {
 		htt->target_version_major = resp->ver_resp.major;
@@ -1932,30 +2008,6 @@ void ath10k_htt_t2h_msg_handler(struct a
 		ath10k_peer_unmap_event(htt, &ev);
 		break;
 	}
-	case HTT_T2H_MSG_TYPE_MGMT_TX_COMPLETION: {
-		struct htt_tx_done tx_done = {};
-		int status = __le32_to_cpu(resp->mgmt_tx_completion.status);
-
-		tx_done.msdu_id =
-			__le32_to_cpu(resp->mgmt_tx_completion.desc_id);
-
-		switch (status) {
-		case HTT_MGMT_TX_STATUS_OK:
-			tx_done.success = true;
-			break;
-		case HTT_MGMT_TX_STATUS_RETRY:
-			tx_done.no_ack = true;
-			break;
-		case HTT_MGMT_TX_STATUS_DROP:
-			tx_done.discard = true;
-			break;
-		}
-
-		spin_lock_bh(&htt->tx_lock);
-		ath10k_txrx_tx_unref(htt, &tx_done);
-		spin_unlock_bh(&htt->tx_lock);
-		break;
-	}
 	case HTT_T2H_MSG_TYPE_TX_COMPL_IND:
 		spin_lock_bh(&htt->tx_lock);
 		__skb_queue_tail(&htt->tx_compl_q, skb);
@@ -1980,9 +2032,6 @@ void ath10k_htt_t2h_msg_handler(struct a
 		ath10k_htt_rx_frag_handler(htt, &resp->rx_frag_ind);
 		break;
 	}
-	case HTT_T2H_MSG_TYPE_TEST:
-		/* FIX THIS */
-		break;
 	case HTT_T2H_MSG_TYPE_STATS_CONF:
 		trace_ath10k_htt_stats(ar, skb->data, skb->len);
 		break;
@@ -2017,20 +2066,6 @@ void ath10k_htt_t2h_msg_handler(struct a
 		 */
 		break;
 	}
-	case HTT_T2H_MSG_TYPE_RX_IN_ORD_PADDR_IND: {
-		spin_lock_bh(&htt->rx_ring.lock);
-		__skb_queue_tail(&htt->rx_in_ord_compl_q, skb);
-		spin_unlock_bh(&htt->rx_ring.lock);
-		tasklet_schedule(&htt->txrx_compl_task);
-		return;
-	}
-	case HTT_T2H_MSG_TYPE_TX_CREDIT_UPDATE_IND:
-		/* FIXME: This WMI-TLV event is overlapping with 10.2
-		 * CHAN_CHANGE - both being 0xF. Neither is being used in
-		 * practice so no immediate action is necessary. Nevertheless
-		 * HTT may need an abstraction layer like WMI has one day.
-		 */
-		break;
 	default:
 		ath10k_warn(ar, "htt event (%d) not handled\n",
 			    resp->hdr.msg_type);
@@ -2038,7 +2073,7 @@ void ath10k_htt_t2h_msg_handler(struct a
 				skb->data, skb->len);
 		break;
 	};
-
+out:
 	/* Free the indication buffer */
 	dev_kfree_skb_any(skb);
 }
