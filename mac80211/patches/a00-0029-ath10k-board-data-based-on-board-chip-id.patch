--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -884,6 +884,46 @@ err:
 	return ret;
 }
 
+static int ath10k_get_board_id_from_otp(struct ath10k *ar)
+{
+	u32 result, address = ar->hw_params.patch_load_addr;
+	u8 board_id, chip_id;
+	int ret;
+
+	if (!ar->otp_data || !ar->otp_len) {
+		ath10k_warn(ar, "Invalid otp ((otp-data %p otp_len %zd)!\n",
+			    ar->otp_data, ar->otp_len);
+		return 0;
+	}
+
+	ath10k_dbg(ar, ATH10K_DBG_BOOT, "boot upload otp to 0x%x len %zd\n",
+		   address, ar->otp_len);
+
+	ret = ath10k_bmi_fast_download(ar, address, ar->otp_data, ar->otp_len);
+	if (ret) {
+		ath10k_err(ar, "could not write otp (%d)\n", ret);
+		return ret;
+	}
+
+	ret = ath10k_bmi_execute(ar, address, BMI_PARAM_GET_EEPROM_BOARD_ID,
+				 &result);
+	if (ret) {
+		ath10k_err(ar, "could not execute otp for board id(%d)\n", ret);
+		return ret;
+	}
+
+	board_id = MS(result, ATH10K_BOARD_ID);
+	chip_id = MS(result, ATH10K_CHIP_ID);
+
+	ath10k_dbg(ar, ATH10K_DBG_BOOT, "got board id from target %d\n",
+		   result);
+
+	scnprintf(ar->spec_board_id, sizeof(ar->spec_board_id),
+		  "%04x-%04x", board_id, chip_id);
+
+	return 0;
+}
+
 static int ath10k_core_fetch_firmware_files(struct ath10k *ar)
 {
 	int ret;
@@ -892,10 +932,12 @@ static int ath10k_core_fetch_firmware_fi
 	if (!no_calfile)
 		ath10k_fetch_cal_file(ar);
 
-	ret = ath10k_core_fetch_board_file(ar);
-	if (ret) {
-		ath10k_err(ar, "failed to fetch board file: %d\n", ret);
-		return ret;
+	if (!ar->board_id_from_otp) {
+		ret = ath10k_core_fetch_board_file(ar);
+		if (ret) {
+			ath10k_err(ar, "failed to fetch board file: %d\n", ret);
+			return ret;
+		}
 	}
 
 	ar->fw_api = 5;
@@ -936,6 +978,20 @@ static int ath10k_core_fetch_firmware_fi
 success:
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "using fw api %d\n", ar->fw_api);
 
+	if (!ar->board_id_from_otp)
+		return 0;
+
+	ret = ath10k_get_board_id_from_otp(ar);
+	if (ret) {
+		ath10k_err(ar, "failed to get board_id from otp\n");
+		return ret;
+	}
+
+	ret = ath10k_core_fetch_board_file(ar);
+	if (ret) {
+		ath10k_err(ar, "failed to fetch board file: %d\n", ret);
+		return ret;
+	}
 	return 0;
 }
 
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -131,6 +131,14 @@ static inline u32 host_interest_item_add
 	return QCA988X_HOST_INTEREST_ADDRESS + item_offset;
 }
 
+#define ATH10K_BOARD_ID_MASK	0x7c00
+#define ATH10K_BOARD_ID_LSB	10
+
+#define ATH10K_CHIP_ID_MASK	0x18000
+#define ATH10K_CHIP_ID_LSB	15
+
+#define BMI_PARAM_GET_EEPROM_BOARD_ID 0x10
+
 struct ath10k_bmi {
 	bool done_sent;
 };
@@ -665,6 +673,8 @@ struct ath10k {
 	char spec_board_id[100];
 	bool spec_board_loaded;
 
+	bool board_id_from_otp;
+
 	int fw_api;
 	enum ath10k_cal_mode cal_mode;
 
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -2942,11 +2942,16 @@ static int ath10k_pci_probe(struct pci_d
 	ar_pci->ar = ar;
 	ar->dev_id = pci_dev->device;
 
-	if (pdev->subsystem_vendor || pdev->subsystem_device)
+	if (QCA_REV_99X0(ar))
+		ar->board_id_from_otp = true;
+
+	if ((pdev->subsystem_vendor || pdev->subsystem_device) &&
+	    !ar->board_id_from_otp) {
 		scnprintf(ar->spec_board_id, sizeof(ar->spec_board_id),
 			  "%04x:%04x:%04x:%04x",
 			  pdev->vendor, pdev->device,
 			  pdev->subsystem_vendor, pdev->subsystem_device);
+	}
 
 	spin_lock_init(&ar_pci->ce_lock);
 	spin_lock_init(&ar_pci->ps_lock);
