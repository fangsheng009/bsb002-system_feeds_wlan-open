--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -4487,6 +4487,15 @@ void ieee80211_stop_queue(struct ieee802
 int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);
 
 /**
+ * ieee80211_queues_stopped - test status of any queue
+ * @hw: pointer as obtained from ieee80211_alloc_hw().
+ *
+ * Return: %true if any queue is stopped. %false otherwise.
+ */
+
+int ieee80211_queues_stopped(struct ieee80211_hw *hw, void *sdata);
+
+/**
  * ieee80211_stop_queues - stop all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2930,6 +2930,13 @@ void __ieee80211_subif_start_xmit(struct
 netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
+#ifdef CPTCFG_MAC80211_NSS_SUPPORT
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+
+	if (ieee80211_queues_stopped(&local->hw, sdata))
+		return NETDEV_TX_BUSY;
+#endif
 	__ieee80211_subif_start_xmit(skb, dev, 0);
 	return NETDEV_TX_OK;
 }
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -581,6 +581,29 @@ ieee80211_get_vif_queues(struct ieee8021
 	return queues;
 }
 
+int ieee80211_queues_stopped(struct ieee80211_hw *hw, void *sdata)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	unsigned long flags;
+	unsigned long queues;
+	int i, ret;
+
+	queues = ieee80211_get_vif_queues(local,
+				(struct ieee80211_sub_if_data *)sdata);
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+
+	for_each_set_bit(i, &queues, hw->queues) {
+		ret = test_bit(IEEE80211_QUEUE_STOP_REASON_DRIVER,
+			       &local->queue_stop_reasons[i]);
+		if (ret)
+			break;
+	}
+
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(ieee80211_queues_stopped);
+
 void __ieee80211_flush_queues(struct ieee80211_local *local,
 			      struct ieee80211_sub_if_data *sdata,
 			      unsigned int queues, bool drop)
