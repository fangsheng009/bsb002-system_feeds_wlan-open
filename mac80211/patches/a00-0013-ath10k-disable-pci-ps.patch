--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -467,12 +467,39 @@ static int ath10k_pci_wake_wait(struct a
 	return -ETIMEDOUT;
 }
 
+static void ath10k_pci_force_wake(struct ath10k *ar)
+{
+	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
+	int ret = 0;
+
+	iowrite32(PCIE_SOC_WAKE_V_MASK,
+			ar_pci->mem + PCIE_LOCAL_BASE_ADDRESS +
+			PCIE_SOC_WAKE_ADDRESS);
+
+	ret = ath10k_pci_wake_wait(ar);
+	if (ret == 0)
+		ar_pci->ps_awake = true;
+}
+
+static void ath10k_pci_force_sleep(struct ath10k *ar)
+{
+	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
+
+	iowrite32(PCIE_SOC_WAKE_RESET,
+			ar_pci->mem + PCIE_LOCAL_BASE_ADDRESS +
+			PCIE_SOC_WAKE_ADDRESS);
+	ar_pci->ps_awake = false;
+}
+
 static int ath10k_pci_wake(struct ath10k *ar)
 {
 	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
 	unsigned long flags;
 	int ret = 0;
 
+	if (!ar_pci->pci_ps)
+		return ret;
+
 	spin_lock_irqsave(&ar_pci->ps_lock, flags);
 
 	ath10k_dbg(ar, ATH10K_DBG_PCI_PS, "pci ps wake refcount %lu awake %d\n",
@@ -504,6 +531,9 @@ static void ath10k_pci_sleep(struct ath1
 	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
 	unsigned long flags;
 
+	if (!ar_pci->pci_ps)
+		return;
+
 	spin_lock_irqsave(&ar_pci->ps_lock, flags);
 
 	ath10k_dbg(ar, ATH10K_DBG_PCI_PS, "pci ps sleep refcount %lu awake %d\n",
@@ -546,6 +576,11 @@ static void ath10k_pci_sleep_sync(struct
 	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
 	unsigned long flags;
 
+	if (!ar_pci->pci_ps) {
+		ath10k_pci_force_sleep(ar);
+		return;
+	}
+
 	del_timer_sync(&ar_pci->ps_timer);
 
 	spin_lock_irqsave(&ar_pci->ps_lock, flags);
@@ -2400,6 +2435,9 @@ static int ath10k_pci_hif_resume(struct
 	struct pci_dev *pdev = ar_pci->pdev;
 	u32 val;
 
+	if (!ar_pci->pci_ps)
+		ath10k_pci_force_wake(ar);
+
 	/* Suspend/Resume resets the PCI configuration space, so we have to
 	 * re-disable the RETRY_TIMEOUT register (0x41) to keep PCI Tx retries
 	 * from interfering with C3 CPU state. pci_restore_state won't help
@@ -2504,6 +2542,9 @@ static irqreturn_t ath10k_pci_interrupt_
 	struct ath10k *ar = arg;
 	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
 
+	if (!ar_pci->pci_ps)
+		ath10k_pci_force_wake(ar);
+
 	if (ar_pci->num_msi_intrs == 0) {
 		if (!ath10k_pci_irq_pending(ar))
 			return IRQ_NONE;
@@ -2910,17 +2951,21 @@ static int ath10k_pci_probe(struct pci_d
 	struct ath10k_pci *ar_pci;
 	enum ath10k_hw_rev hw_rev;
 	u32 chip_id;
+	u8 pci_ps = 0;
 
 	switch (pci_dev->device) {
 	case QCA988X_2_0_DEVICE_ID:
 		hw_rev = ATH10K_HW_QCA988X;
+		pci_ps = 0;
 		break;
 	case QCA6164_2_1_DEVICE_ID:
 	case QCA6174_2_1_DEVICE_ID:
 		hw_rev = ATH10K_HW_QCA6174;
+		pci_ps = 1;
 		break;
 	case QCA99X0_2_0_DEVICE_ID:
 		hw_rev = ATH10K_HW_QCA99X0;
+		pci_ps = 0;
 		break;
 	default:
 		WARN_ON(1);
@@ -2940,6 +2985,7 @@ static int ath10k_pci_probe(struct pci_d
 	ar_pci->pdev = pdev;
 	ar_pci->dev = &pdev->dev;
 	ar_pci->ar = ar;
+	ar_pci->pci_ps = pci_ps;
 	ar->dev_id = pci_dev->device;
 
 	if (pdev->subsystem_vendor || pdev->subsystem_device)
@@ -2988,6 +3034,9 @@ static int ath10k_pci_probe(struct pci_d
 		goto err_deinit_irq;
 	}
 
+	if (!ar_pci->pci_ps)
+		ath10k_pci_force_wake(ar);
+
 	ret = ath10k_pci_chip_reset(ar);
 	if (ret) {
 		ath10k_err(ar, "failed to reset chip: %d\n", ret);
--- a/drivers/net/wireless/ath/ath10k/pci.h
+++ b/drivers/net/wireless/ath/ath10k/pci.h
@@ -221,6 +221,8 @@ struct ath10k_pci {
 	 * powersave register state changes.
 	 */
 	bool ps_awake;
+
+	u8 pci_ps;
 };
 
 static inline struct ath10k_pci *ath10k_pci_priv(struct ath10k *ar)
